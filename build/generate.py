#!/bin/python3

import os
import re

HEADER = """// This file is generated by CMake.
// Do not modify by hand.

#include <string>
#include "pancake/pancake.hpp"

using std::string;

"""

class Class:

    def __init__(self, contents):

        # Get the name of the class.
        match = re.search(r'class\s+[a-zA-Z_][a-zA-Z0-9_]*', contents, flags=re.DOTALL)
        name = match.group()
        name = re.sub(r'class\s+', '', name)
        name = name.strip()
        self.name = name

        # Get the classes that this class inherits.
        self.inherits = []
        match = re.search(r'class\s+.*:.*{', contents, flags=re.DOTALL)
        if match != None:

            # Get all the classes that it inherits.
            bases_string = match.group()
            bases_string = re.sub(r'class\s+.*:', '', bases_string)
            bases_string = re.sub(r'{', '', bases_string)

            # Get the names of all classes it inherits.
            bases = bases_string.split(',')
            for i in range(len(bases)): 
                bases[i] = bases[i].strip()
                split = bases[i].split()
                self.inherits.append(split[1])

def get_source_files():

    source_files = []
    for root, _, filenames in os.walk("./../src"):
        for filename in filenames:
            search = re.search(r'[(.cpp)(.cxx)(.cc)]$', filename)
            if search == None: continue
            source_files.append(os.path.join(root, filename))

    return source_files

def get_main(source_files):

    for source_file in source_files:
        
        f = open(source_file, 'r')
        contents = f.read()
        f.close()

        search = re.search(r'int\s+main\s*\(.*\)', contents)
        if search == None: continue
        entry = search.group()

        contents = re.sub(r'int\s+main\s*\(', 'int _main(', contents)
        return source_file, contents, entry
    
    return None, None, None

def get_header_files(main_file):

    def recurse(file, list):

        f = open(file, 'r')
        lines = f.readlines()
        f.close()

        for line in lines:

            # Find all #include preprocessor statements
            search = re.search(r'^#include\s*["<].*[">].*', line)
            if search == None: continue
            
            # Get the filename that was included.
            line = re.sub(r'^#include\s*["<]', '', line)
            line = re.sub(r'[">].*', '', line)
            line = line.strip()

            # Check if this file is in the include directory.
            path = './../include/' + line
            if not os.path.isfile(path): continue

            # Add it to the list and recurse into it.
            path = os.path.abspath(path)
            if path in list: continue
            list.append(path)
            recurse(path, list)
        
        return list

    return recurse(main_file, [])

def get_components(files):

    classes = {}
    component_classes = {"Component", "TransformableComponent"}
    components = set()

    for file in files:
        
        # Read the entire file as a string.
        f = open(file, 'r')
        contents = f.read()

        # Strip all comments from the code.
        contents = re.sub(r'//.*?(?:\n|$)', '\n', contents)
        contents = re.sub(r'/\*.*?\*/', '', contents, flags=re.DOTALL)

        # While the word class still exists in the code.
        while True:

            # Find the next class in the file
            match = re.search(r'class\s+.*{', contents, flags=re.DOTALL)
            if match == None: break

            # Find the start and end of the class.
            start = match.start()
            end = contents.find('};')+1
            
            # Create a new class object.
            class_contents = contents[start:end]
            new = Class(class_contents)
            classes[new.name] = new

            # Move to seek the next class.
            contents = contents[end:]

    # Recursively find all component classes.
    def recurse(c):

        if c in component_classes:
            return True

        for b in c.inherits:

            if b in component_classes: 
                component_classes.add(c.name)
                components.add(c.name)
                return True

            if b in classes:
                if recurse(b):
                    component_classes.add(c.name)
                    components.add(c.name)
                    return True

        return False

    # Run the recursive algorithm on each class.
    for c in classes.values():
        recurse(c)
    
    # Return the list of newly discovered components.
    return list(components)

def create_component(class_name):
    return f'void* {class_name}_Create() ' + '{return new ' + class_name + '();}\n'

def add_component(class_name):
    return "\tComponentFactory::add(\"" + class_name + "\", " + class_name + "_Create);\n"

def add_main(entry):

    search = re.search(r'\(.*\)', entry)
    args_string = search.group()
    args_string = re.sub(r'[\(\)]', '', args_string)
    args = args_string.split(',')

    for i in range(len(args)):
        split = re.split(r'[\s\*]', args[i])
        if len(split) > 1:
            args[i] = split[-1]
            args[i] = re.sub(r'\[\]', '', args[i])
            args[i] = args[i].strip()

    result = entry + '{\n'
    result += '\t_register();\n'
    result += '\treturn _main('
    for i in range(len(args) - 1): result += args[i] + ', '
    if len(args) > 0: result += args[-1] + ');\n'
    result += '}\n'

    return result

def main():

    source_files = get_source_files()
    main_file, main_contents, main_entry = get_main(source_files)
    header_files = get_header_files(main_file)

    class_files = []
    class_files.append(main_file)
    class_files.extend(header_files)

    components = get_components(class_files)

    f = open('main.cpp', 'w')
    f.write(HEADER)
    
    if main_contents == None: f.write('int _main() {return 0;}')
    else: f.write(main_contents)
    f.write('\n\n')

    for c in components:
        f.write(create_component(c))
    f.write("\n")
    
    f.write('void _register() {\n')
    for c in components:
        f.write(add_component(c))
    f.write("}\n\n")

    f.write(add_main(main_entry))

if __name__ == '__main__':
    main()